@layout('layouts/master')

@section('content')
{{csrfField()}}
<style>
@keyframes glowing {
  0% {
    background-color: #fde0e6;
    box-shadow: 0 0 10px #fde0e6;
  }
  50% {
    background-color: #ff0000;
    box-shadow: 0 0 30px #ff0000;
  }
  100% {
    background-color: #fde0e6;
    box-shadow: 0 0 10px #fde0e6;
  }
}

  .glowing {
    animation: glowing 1300ms infinite;
  }
.audioPlayer {
    display: flex;
    justify-content: center;
  align-items: center;
   position: fixed;
   left: 0;
   bottom: 0;
   width: 100%;
   height: 7vh;
   background-color: red;
   color: white;
   text-align: center;
}
.audioPlayer .controls *     {
    display: inline;
}

.controls .play, .controls .pause {
  margin: 15px 25px;
  color: #6e946c;
}
.controls .volume {
  margin-right: 30px;
  font-size: 0.8em;
}
.inline {
  display: inline-block;
}
.vertically-centered {
  display: inline-block;
  vertical-align: middle;
  line-height: normal;
}
</style>

@set("faces", ["https://images.generated.photos/IyhiaDSy30MuFzgVenEmOhM4thtrNz1M8aFvFFqHabk/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LmNvbmQvMGI3YTk5/MDItNmRjNS00MWUz/LTgzYTgtZGQ3YzA3/YzAyZTQxLmpwZw.jpg", "https://images.generated.photos/vaI3Meqsw3KjgcPFXYLX1VW2BUERcurt8d17la--wzc/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LmNvbmQvNjFmMDcz/ODktMGFkZi00ZDYw/LTk4MjAtY2Q3YTAx/MGFmYWI1LmpwZw.jpg", "https://images.generated.photos/ngLmCFtNOfogoWtneXHOM8NiVTK1xHmt1efQ6lCo_2g/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LmNvbmQvMGVmNGNk/NjgtN2ZjOC00NTlj/LWFlYTgtZjVjMjdj/OWI1YzhlLmpwZw.jpg", "https://images.generated.photos/qx0_FoMRdd-_g48rdS_AW61Lym_5R4JEtDoZeIltnZQ/rs:fit:512:512/wm:0.95:sowe:18:18:0.33/czM6Ly9pY29uczgu/Z3Bob3Rvcy1wcm9k/LmNvbmQvZWFhZDg3/MmYtOTg3Yy00Y2Ux/LWEwMTYtN2RlZTg1/MjQ4YzEzLmpwZw.jpg"])
@set("didascalie", "https://www.yapasdequoi.com/wp-content/uploads/2012/10/guillemets_francais.gif")

@each((character, index) in characters)
<div id="character_{{character.id}}" class="characterSelect" data-array-index="{{index}}">
    <figure class="image is-128x128 inline">
        <img src="{{character.id === 1 ? didascalie : faces[index]}}">
    </figure>
    <span class="inline vertically-centered">{{character.name}}</span>
    <select name="lineVersions" class="lineVersionSelect">
        <option value="" selected="selected">Sélectionnez une version !</option>
        <option value="0">Créer une alternative!</option>
    </select>
    <select name="doublers" class="doublerSelect">
        <option value="" selected="selected">Sélectionnez un doubleur !</option>
        <option value="record">Devenez le doubleur !</option>
        <option value="robot">Robotiser</option>
    </select>
    <select name="audioVersions" class="audioVersionSelect">
        <option value="" selected="selected">Sélectionnez une intérprétation !</option>
        <option value="0">Enregistrer votre intérprétation !</option>
    </select>
</div>
@endeach


@each(line in lines)
<div class="container mt-4">
    <div class="card">
      <div class="card-content">
        <nav class="level">
          <!-- Left side -->
          <div class="level-left ml-4">
            <div class="level-item">
              <p class="subtitle is-5">
                <strong class="characterId">{{line.character.id}}</strong>
              <div class="is-divider-vertical"></div>
              </p>
            </div>
            <div class="level-item">
                <figure class="image is-256x256">
                    <img class="is-rounded" src="https://www.gravatar.com/avatar/205e460b479e2e5b48aec07710c08d50?f=y">
                </figure>
            </div>
          </div>
  
          <div class="level-item has-text-centered mr-6 ml-6" id="line_pos_{{line.position}}">
            <textarea id="line_{{line.id}}" class="textarea is-info has-fixed-size is-small" placeholder="Info textarea" {{!line.isAlternative ? "readonly" : "" }}>{{line.text}}</textarea>
          </div>
  
          <!-- Right side -->
          <div class="level-right" id="buttonControl_{{line.position}}">
            <p class="level-item">
              {{--  maybe we can use columns??  --}}
                <button class="button is-danger is-light is-inverted is-focused btnRecordControl" style="display: {{'none'.repeat(!line.toBeRecorded)}}">
                  <span class="icon" style="pointer-events: none;">
                    <i class="fa fa-solid fa-microphone" style="pointer-events: none;"></i>
                  </span>
                  <span style="pointer-events: none;">Enregistrer !</span> 
                </button> 
                <button data-line-id="{{line.id}}" class="button is-danger is-light is-inverted is-focused btnUpload ml-3" style="display:none">
                  <span class="icon" style="pointer-events: none;">
                    <i class="fa fa-solid fa-upload" style="pointer-events: none;"></i>
                  </span>
                </button> 
                <button class="button is-danger is-light is-inverted is-focused btnCancel ml-3" style="display:none">
                  <span class="icon" style="pointer-events: none;">
                    <i class="fa fa-solid fa-eraser" style="pointer-events: none;"></i>
                  </span>
                </button>
                <button class="button is-info is-light is-inverted is-focused btnRobotize" style="display: {{'none'.repeat(+!line.isRobotized)}}">
                  <span class="icon">
                    <i class="fa fa-solid fa-robot"></i>
                  </span>
                  <span>Robotiser !</span>  
                </button>
                <button class="button is-primary is-light is-inverted is-focused btnPlay" data-position="{{line.position}}" data-version="{{line?.audios?.[0].version.id ?? ''}}" style="display: {{'none'.repeat(+!line?.audios?.length)}}">
                    <span class="icon">
                        <i class="fa fa-solid fa-play"></i>
                    </span>
                    <span>Lire !</span>
                </button>  
                
            </p>
          </div>
        </nav>
      </div>
    </div>
  </div>
@endeach

<div class="audioPlayer">
    <div class="controls">
        <div class="previousScene"><i class="fas fa-hand-point-left"></i></div>
        <div class="previousLine"><i class="fas fa-backward"></i></div>
        <div class="play">
            <button id="btnPlay">
                <i class="fas fa-play"></i>
            </button>   
        </div>
        <div class="pause" style="display: none">
            <button id="btnPause">
                <i class="fas fa-pause"></i>
            </button>   
        </div>
        <div class="reset">
            <button id="btnReset">
                <i class="fas fa-stop"></i>
            </button>   
        </div>
        <div class="nextLine"><i class="fa fa-forward"></i></div>
        <div class="nextScene"><i class="fa fa-forward-fast"></i></div>
    </div>
</div>
<audio id="player" style="display: none"></audio>

<script>
const CSRF_TOKEN = document.getElementsByName("_csrf")[0].value;
const globalAudios = Array.from(JSON.parse(`{{{stringify(audios)}}}`)); // FIXME find a more elegant way to pass data to frontend

const characters = Array.from(JSON.parse(`{{{stringify(characters)}}}`));
document.addEventListener("DOMContentLoaded",  () => {

  const setOptions = (options, parent) => {
    options.forEach((option, index) => {
      const optionElement = document.createElement("option");
      optionElement.text = option?.name ?? option.username;
      optionElement.value = option.id;
      optionElement.setAttribute("data-array-index", index);
      parent.add(optionElement);
    })
  };

  const textAreaCallback = (event) => {
    console.log(event.target.textContent);
  }

  const audioVersionCallback = (event, characterIndex, lineVersionSelect, doublerVersionSelect) => {
    const currentCharacter = characters[characterIndex];
    console.log(currentCharacter)
    const selectedAudioVersion = event.target.options[event.target.selectedIndex].value
    const selectedLineVersion = lineVersionSelect.options[lineVersionSelect.selectedIndex].value
    const selectedDoubler = doublerVersionSelect.options[doublerVersionSelect.selectedIndex].value
    if (!(selectedAudioVersion && selectedDoubler && selectedLineVersion)) return;

    console.log("audio version change", selectedLineVersion, selectedDoubler, selectedAudioVersion);

    const cookedVersion = `${currentCharacter.id}-${selectedLineVersion}-${selectedDoubler}-${selectedAudioVersion}`;
    const form = new FormData();
    form.append("version", cookedVersion);
    // `${window.location.href}/../character/${currentCharacter.id}/lineVersion/${selectedLineVersion}/doubler/${selectedDoubler}/audioVersion/${selectedAudioVersion}/change`
    fetch(`${window.location.href}/../change`, {
        method: "POST",
        headers: {
            'X-CSRF-Token': CSRF_TOKEN,
            /* 'Accept': `${blob.type}`, // FIXME: Not working while file transfer?
            'Content-Type': `${blob.type}`,*/ 
            'Content-Transfer-Encoding': 'base64'
        },
        mode: "cors",
        body: form
    }).then(response => {
        if (!response.ok) throw response;
        return response.json();
    }).then((data) => {
        const lines = data.lines;
        const audios = data.audios;
        lines.map((line) => {
          console.log(line, "line")
          const positonID = `line_pos_${line.position}`;
          const lineElement = document.querySelector(`#${positonID} textarea`);
          const buttonControl = document.getElementById(`buttonControl_${line.position}`);
          const buttonRecordControl = buttonControl.querySelector(".btnRecordControl");
          const buttonRobotize = buttonControl.querySelector(".btnRobotize");
          const buttonPlay = buttonControl.querySelector(".btnPlay");
          console.log(buttonRecordControl, buttonRobotize, buttonPlay)
          buttonRecordControl.style.display = "none";
          buttonRobotize.style.display = "none";
          btnPlay.style.display = "none";
          lineElement.readOnly = true;
          lineElement.setAttribute("data-version", line.version_id);
          lineElement.textContent = line.text;
          lineElement.oninput = null;
          if (line.isAlternative) {
            buttonRecordControl.style.display = "inline";
            console.log(`Setting up the recording stage!`);
          } else if(line.isRobotized) {
            buttonRobotize.style.display = "inline";
            lineElement.readOnly = false;
            lineElement.oninput = textAreaCallback;
            console.log(`Setting up the Speec2Text`);
          } else if(line.audios.length) {
            btnPlay.style.display = "inline-block";
            const audio = line.audios[0];
            globalAudios[line.position] = audio;
            console.log(`Fetched audio: ${audio.public_path}`);
          }
          
        })
        // window.location.reload();
    }).catch((err) => {
        console.error(err);
    })
  }

  const doublerCallback = (event, lineVersionSelect, closestAudioVersionSelect, characterIndex, lineVersionIndex) => {
      // FIXME using such a nested event listener attaching due to the fact that our main object gets relationed (nested). So, we're benefiting it to reduce recurant variable definitions.
      console.log("lineversion index", lineVersionIndex)
      closestAudioVersionSelect.style.display = "inline";
      const selectedOption = event.target.options[event.target.selectedIndex]
      console.log("doubler change", selectedOption)
      if (!selectedOption.value) return;
      if (selectedOption.value === "robot") {
        closestAudioVersionSelect.style.display = "none";
        console.log("robotization starts")
      const currentCharacter = characters[characterIndex];
    console.log(currentCharacter)
    const selectedLineVersion = lineVersionSelect.options[lineVersionSelect.selectedIndex].value
    const cookedVersion = `${currentCharacter.id}-${selectedLineVersion}-robot-0`;
    const form = new FormData();
    form.append("version", cookedVersion);
    // `${window.location.href}/../character/${currentCharacter.id}/lineVersion/${selectedLineVersion}/doubler/${selectedDoubler}/audioVersion/${selectedAudioVersion}/change`
    fetch(`${window.location.href}/../change`, {
        method: "POST",
        headers: {
            'X-CSRF-Token': CSRF_TOKEN,
            /* 'Accept': `${blob.type}`, // FIXME: Not working while file transfer?
            'Content-Type': `${blob.type}`,*/ 
            'Content-Transfer-Encoding': 'base64'
        },
        mode: "cors",
        body: form
    }).then(response => {
        if (!response.ok) throw response;
        return response.json();
    }).then((data) => {
        const lines = data.lines;
        lines.map((line) => {
          console.log(line, "line")
          const positonID = `line_pos_${line.position}`;
          const lineElement = document.querySelector(`#${positonID} textarea`);
          const buttonControl = document.getElementById(`buttonControl_${line.position}`);
          const buttonRecordControl = buttonControl.querySelector(".btnRecordControl");
          const buttonRobotize = buttonControl.querySelector(".btnRobotize");
          const buttonPlay = buttonControl.querySelector(".btnPlay");
          console.log(buttonRecordControl, buttonRobotize, buttonPlay)
          buttonRecordControl.style.display = "none";
          buttonRobotize.style.display = "none";
          btnPlay.style.display = "none";
          lineElement.readOnly = true;
          lineElement.setAttribute("data-version", line.version_id);
          lineElement.textContent = line.text;
          lineElement.oninput = null;
          if (line.isAlternative) {
            buttonRecordControl.style.display = "inline";
            console.log(`Setting up the recording stage!`);
          } else if(line.isRobotized) {
            buttonRobotize.style.display = "inline";
            lineElement.readOnly = false;
            lineElement.oninput = textAreaCallback;
            console.log(`Setting up the Speec2Text`);
          } else if(line.audios.length) {
            btnPlay.style.display = "inline-block";
            const audio = line.audios[0];
            globalAudios[line.position] = audio;
            console.log(`Fetched audio: ${audio.public_path}`);
          }
          
        })
        // window.location.reload();
    }).catch((err) => {
        console.error(err);
        closestAudioVersionSelect.style.display = "none";
      });
      
    }
      else if(selectedOption.value === "record") {
        console.log("You'll be recoding soon!");
      }
      else if (lineVersionIndex) {
        const doublerIndex = selectedOption.getAttribute("data-array-index");
        closestAudioVersionSelect.length = 2;
        const audioVersions = characters[characterIndex].versions[lineVersionIndex].doublers[doublerIndex].audioVersions;
        console.log(audioVersions);
        setOptions(audioVersions, closestAudioVersionSelect);
      }
      closestAudioVersionSelect.onchange = null;
        /* closestAudioVersionSelect.addEventListener("change", (audioVersionEvent) => {
            audioVersionCallback(audioVersionEvent, lineVersionSelect, event.target);
        })      */
        closestAudioVersionSelect.onchange = (audioVersionEvent) => {
            audioVersionCallback(audioVersionEvent, characterIndex, lineVersionSelect, event.target);
        }
      
      //closestAudioVersionSelect.removeEventListener("change", audioVersionCallback);
      
  }

  const lineVersionCallback = (event, lineVersionSelect) => {
      const selectedOption = event.target.options[event.target.selectedIndex]
      console.log("line version change", selectedOption)
      const dialogRoot = lineVersionSelect.closest(".characterSelect"); // This'll be the each character div
      const closestDoublerSelect = dialogRoot.querySelector(".doublerSelect");
      const closestAudioVersionSelect = dialogRoot.querySelector(".audioVersionSelect");
      const characterIndex = parseInt(dialogRoot.getAttribute("data-array-index"));
      let lineVersionIndex = null;
      if (selectedOption.value === "0") {
        console.log("Create your own alternative!")
        closestDoublerSelect.length = 2;
      }
      else if (!selectedOption.value) return;
      else {
        lineVersionIndex = selectedOption.getAttribute("data-array-index");
        console.log(`this is the ${lineVersionIndex} indexed line version`)
        const doublers = characters?.[characterIndex].versions?.[lineVersionIndex].doublers ?? [];
        setOptions(doublers, closestDoublerSelect);
        closestDoublerSelect.length = 2;
        const robotizeSelect = document.createElement("option");
        robotizeSelect.value = "robot";
        robotizeSelect.textContent = "Robotiser !"
        closestDoublerSelect.add(robotizeSelect);
        closestAudioVersionSelect.length = 2;
      }
      closestDoublerSelect.onchange = null;
      closestDoublerSelect.onchange = (doublerEvent) => {
          doublerCallback(doublerEvent, lineVersionSelect, closestAudioVersionSelect, characterIndex, lineVersionIndex)
      }
      
      
  }


  const lineVersionSelectors = Array.from(document.querySelectorAll(".lineVersionSelect"));
  characters.forEach((character, index) => {
      console.log(lineVersionSelectors[index])
      setOptions(character.versions, lineVersionSelectors[index])
  })

  lineVersionSelectors.map((lineVersionSelect) => {
      console.log("bind")
      lineVersionSelect.addEventListener("change", (event) => {
          lineVersionCallback(event, lineVersionSelect);
      })
  })

  console.log(characters);
})

let recording = false;
let mediaRecorder;
const characterToAudioVersion = {}; // To keep track of uploaded audio files by character_id and set them;
const player = document.getElementById("player");
const inlinePlayButtons = Array.from(document.getElementsByClassName("btnPlay"));
const recordControlButtons = Array.from(document.getElementsByClassName("btnRecordControl")) // naming like this, because will also allow stop recording
const robotizeButtons = Array.from(document.getElementsByClassName("btnRobotize"))
const cancelButtons = Array.from(document.getElementsByClassName("btnCancel"));
const uploadButtons = Array.from(document.getElementsByClassName("btnUpload"));
const playButton = document.getElementById("btnPlay");
const pauseButton = document.getElementById("btnPause");
const resetButton = document.getElementById("btnReset");
let currentAudioIndex = 0;

const resetPlayer = (e) => {
    player.pause();
    player.currentTime = 0;
    currentAudioIndex = globalAudios.findIndex((element) => element !== null);
    player.src = globalAudios[currentAudioIndex];
    player.removeEventListener("ended", loadNextAudio);
    // FIXME try to use the purest/native JS
    pauseButton.parentNode.style.display = "none";
    playButton.parentNode.style.display = "inline";
}

const playPlayer = (e) => {
    const position = e.target.getAttribute("data-position");
    if (position) {
      currentAudioIndex = parseInt(position); // TODO Maybe add a pause icon in the line's button
      console.log("inline button")
    }
    pauseButton.parentNode.style.display = "inline";
    playButton.parentNode.style.display = "none";
    if (player.currentTime > 0) return player.play();
    player.src = globalAudios[currentAudioIndex];
    player.addEventListener("ended", loadNextAudio);
    player.play();
}

const pausePlayer = (e) => {
    player.pause();
    pauseButton.parentNode.style.display = "none";
    playButton.parentNode.style.display = "inline";
}

const loadNextAudio = (event) => {
    console.log(event)
    currentAudioIndex++;
    if (currentAudioIndex <= globalAudios.length && globalAudios[currentAudioIndex]) {
        event.target.src = globalAudios[currentAudioIndex];
        event.target.play();
    } else {
        event.target.pause();
        resetPlayer();
    }
}

const uploadAudio = async (event, objectURL) => {
  const characterID = parseInt(event.target.closest(".level").querySelector(".level-left .level-item:first-child .subtitle .characterId").textContent);
  const lineID = event.target.getAttribute("data-line-id");
  console.log("uploading audio!!", objectURL)
  console.log(`Here's the line_id to attach: ${lineID}`);
  event.target.style.display = "none";
  const cancelButton = event.target.parentNode.querySelector(".btnCancel");
  cancelButton.style.display = "none";
  const recordControlButton = event.target.parentNode.querySelector(".btnRecordControl");
  const recordIcon = recordControlButton.querySelector("i");
  recordIcon.classList.remove("fa-play");
  recordIcon.classList.add("fa-microphone");
  event.target.parentNode.querySelector(".btnRecordControl span:nth-child(2)").textContent = "Enregistrer !";
  player.currentTime = 0;
  player.src = "";
  const blob = await fetch(objectURL).then(r => r.blob());
  console.log(blob);
  const form = new FormData();
  form.append("audio", blob);
  form.append("lineId", lineID);
  return; // FIXME
  fetch(`${window.location.origin}/audios`, {
      method: "POST",
      headers: {
          'X-CSRF-Token': CSRF_TOKEN,
          /* 'Accept': `${blob.type}`, // FIXME: Not working while file transfer?
          'Content-Type': `${blob.type}`,*/ 
          'Content-Transfer-Encoding': 'base64'
      },
      mode: "cors",
      body: form
  }).then(response => {
      if (!response.ok) throw response;
      return response.json();
  }).then((data) => {
      const {versionID, public_path} = data;
      characterToAudioVersion[characterID] = versionID;
      // window.location.reload();
  }).catch((err) => {
      console.error(err);
  })

};

const cancelRecording = (event, objectURL) => {
  console.log("canceling recording :(", objectURL)
  event.target.style.display = "none";
  const uploadButton = event.target.parentNode.querySelector(".btnUpload");
  uploadButton.style.display = "none";
  const recordControlButton = event.target.parentNode.querySelector(".btnRecordControl");
  const recordIcon = recordControlButton.querySelector("i");
  recordIcon.classList.remove("fa-play");
  recordIcon.classList.add("fa-microphone");
  event.target.parentNode.querySelector(".btnRecordControl span:nth-child(2)").textContent = "Enregistrer !";
  player.currentTime = 0;
  player.src = "";
  URL.revokeObjectURL(objectURL); // FIXME Invalid URI. Load of media resource  failed.
  
}

const handleMediaDevice = (event, stream, isFirstRecording) => {
    const cancelButton = event.target.parentNode.querySelector(".btnCancel");
    const uploadButton = event.target.parentNode.querySelector(".btnUpload");
    const options = {mimeType: "audio/webm"};
    const recordedChunks = [];
    let objectURL;
    mediaRecorder = new MediaRecorder(stream, options);
    console.log(mediaRecorder.mimeType);
    mediaRecorder.addEventListener("dataavailable", function(e) {
        if (e.data.size > 0) recordedChunks.push(e.data);
    })
    mediaRecorder.addEventListener("stop", (e) => {
      console.log("stopped the media recorder");
      // make the create request here!
      const blob = new Blob(recordedChunks, {type: mediaRecorder.mimeType});
      objectURL = URL.createObjectURL(blob);
      player.src = objectURL;
      // ref: https://stackoverflow.com/questions/11455515/how-to-check-whether-dynamically-attached-event-listener-exists-or-not
      cancelButton.onclick = (_e) => cancelRecording(_e, objectURL);
      uploadButton.onclick = (_e) => uploadAudio(_e, objectURL);

      cancelButton.style.display = "inline";
      uploadButton.style.display = "inline";
      // FIXME how to revoke microphone permissions?

    })
    if (mediaRecorder && mediaRecorder.state !== "recording") mediaRecorder.start();

};

const controlAudioRecord = (event) => {
  const characterID = parseInt(event.target.closest(".level").querySelector(".level-left .level-item:first-child .subtitle .characterId").textContent);
  const cancelButton = event.target.parentNode.querySelector(".btnCancel");
  const uploadButton = event.target.parentNode.querySelector(".btnUpload");
  const icon = event.target.querySelector("i");
  const audioVersion = characterToAudioVersion[characterID];
  const isFirstRecording = !Boolean(audioVersion);
  if (!recording) {
    if (icon.classList.contains("fa-play")) { // playing the recorded one & set upload and delete button
      console.log("now, let's play your recording!")
      player.play();
    } else if (icon.classList.contains("fa-microphone")) {
      event.target.querySelector("span:nth-child(2)").textContent = "Arrêter d'enregistrer !";
    recording = true;
    console.log("starting recording...");
    icon.classList.remove("fa-microphone");
    icon.classList.add("fa-stopwatch");
    event.target.classList.add("glowing");
    console.log(isFirstRecording ? "be prepared! first recording!!" : "not your first one I guess...");
    navigator.mediaDevices.getUserMedia({audio: true, video:false}).then((stream) => handleMediaDevice(event, stream, isFirstRecording))
  }

  } else {
    event.target.querySelector("span:nth-child(2)").textContent = "Lire votre enregistrement !";
    recording = false;
    console.log("stopping recording...");
    // icon.classList.add("fa-microphone");
    icon.classList.remove("fa-stopwatch");
    event.target.classList.remove("glowing");
    if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
    icon.classList.add("fa-play");
  }
}
inlinePlayButtons.map((button) => {
  button.addEventListener("click", playPlayer)
})
playButton.addEventListener("click", playPlayer)
pauseButton.addEventListener("click", pausePlayer)
resetButton.addEventListener("click", resetPlayer)

recordControlButtons.forEach((button) => {
  button.addEventListener("click", controlAudioRecord)
})
/* uploadButtons.forEach((button) => {
  button.addEventListener("click", uploadAudio);
})
cancelButtons.forEach((button) => {
  button.addEventListener("click", cancelRecording);
}) */

</script>
@endsection