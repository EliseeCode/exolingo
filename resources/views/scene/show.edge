@layout('layouts/master')
@section('css')
<link rel="stylesheet" href="/css/selectize.css">
@endsection
@section('js')
<script src="/js/bulma-dropdown.js"></script>
<script src="/js/bulma-modal.js"></script>
@endsection
@section('content')
<style>
    .selectAudioVersion{
        display:none;
    }
    .actionLineContainer:hover .selectAudioVersion{
        display:inline-block;
    }

    .selectLineVersion{
        display:none;
    }
    .line:hover .selectLineVersion{
        display:inline-block;
    }
    .saved textarea{
        background-color:#00FF8050;
        position:relative;
    }
    .saved::after{
        content:"Enregistré";
        color:green;
        position:absolute;
        bottom:5px;
        right:5px;}
    
    .lineText{
        margin-bottom:3px;
        overflow:hidden;
    }
    .lineText:read-only{
        border:none;
        box-shadow:none;
    }
    .image-character{
    width:40px;
    height:40px;
    }
   
    .lineContainer{position:relative;}
    @keyframes glowing {
  0% {
    background-color: #fde0e6;
    box-shadow: 0 0 10px #fde0e6;
  }
  50% {
    background-color: #ff0000;
    box-shadow: 0 0 30px #ff0000;
  }
  100% {
    background-color: #fde0e6;
    box-shadow: 0 0 10px #fde0e6;
  }
}

  .glowing {
    animation: glowing 1300ms infinite;
  }
.audioPlayer {
    display: flex;
    justify-content: center;
  align-items: center;
   position: fixed;
   left: 0;
   bottom: 0;
   width: 100%;
   height: 7vh;
   background-color: red;
   color: white;
   text-align: center;
}
.audioPlayer .controls *     {
    display: inline;
}

.controls .play, .controls .pause {
  margin: 15px 25px;
  color: #6e946c;
}
.controls .volume {
  margin-right: 30px;
  font-size: 0.8em;
}
.inline {
  display: inline-block;
}
.vertically-centered {
  display: inline-block;
  vertical-align: middle;
  line-height: normal;
}
.lineContainer{
    min-width:80%;
    text-align:center;
    margin-bottom:200px;
}
.line{display:inline-block;}
.selectAudioVersion select{
    border:none;
    font-size:1em;}
.selectLineVersion select{
    border:none;
    font-size:1em;}
.selectLineVersion,.selectAudioVersion{
    font-size: 0.8em;
    color:grey;
    width: fit-content;
}    
    
</style>





<div class="container mt-3">
<div class="level">
        <div class="level-item">
            <div>
            <h1 class="title">
                {{scene.play.name}}
            </h1>
            </div>
        </div>
</div>    
{{--  Select other scene from this play  --}}
<div class="level">
    <div class="level-item">
        <div>
            <h2 class="subtitle">
                <div class="select">
                    <select name="scene" id="" oninput="window.location.href = '/scenes/'+this.value">
                        @each(sceneFromPlay in scene.play.scenes)
                        <option value="{{sceneFromPlay.id}}" {{sceneFromPlay.id==scene.id?'selected':''}}>{{sceneFromPlay.name}}</option>
                        @endeach
                    </select>
                </div>
            </h2>
        </div>
    </div>
</div>    
    

    <h2 class="subtitle">
        {{scene.description}}
    </h2>
</div>    
    <hr>
    
    {{--  LineContainer  --}}
    
    <div class="level" style="align-items:flex-start;">
        <div class="level-item" style="border-left:2px white solid;">
            <div class="lineContainer box"> 
                @set('position',null)
                
                @each((line,indexLine) in scene.lines)
                        @if(line.position!=position)
                            @include('partials/scenes/show/newLine')  
                        @endif
                        @set('position',line.position)
                            @include('partials/scenes/show/line')    
                            <br>
                @endeach
            </div>
        </div>
    </div>
    





    <div class="csrfToken" data-csrf-token="{{ csrfToken }}"></div>
    <audio id="player"></audio>
        
    <script>

    ////////////////////
    // GLOBALS
    ////////////////////
        const globalAudios = new Array(parseInt("{{sceneLength}}")).fill(0); // for robot
        const characterToAudioVersion = {};
        let recording = false;
        let mediaRecorder;
        let characterIds=new Set();
        const userId={{auth.user?.id || 0}};

    ////////////////////
    // INITIALISATION GLOBALS
    ////////////////////
    $(".selectLineVersion select").each(function(){
            characterIds.add($(this).data('character-id'))
    })
    characterIds.forEach((characterId)=>{updateLineVersion(characterId,1);}); 
    
    ////////////////////
    // LINE VERSION SELECTION
    ////////////////////
        

        $(".selectLineVersion select").on('change',function(e){
            const audioVersionSelect = e.target.closest(".characterSelect").querySelector(".selectAudioVersion select");
            var characterId=$(this).data('character-id');
            var versionId=$(this).val();
            updateLineVersion(characterId,versionId);
        })

        function updateLineVersion(characterId,versionId)
        {
            UpdateDisplaySelectLineVersion(characterId,versionId);
            //if it is a real lineVersion
            if(versionId>0){
                console.log('versionId',versionId);
                UpdateDisplayLineVersion(characterId,versionId);
                getAudioVersion(characterId,versionId)
            }else{
            //if it is 0=>Create a new text alternative
                createNewLineVersion(characterId);
            }
        }
        function UpdateDisplaySelectLineVersion(characterId,versionId){
            $(".characterSelect_"+characterId+" .selectLineVersion select").val(versionId);
        }
        function UpdateDisplayLineVersion(characterId,versionId)
        {
            $(".lineCharacter_"+characterId).hide();
            $(".lineCharacter_"+characterId+".lineVersion_"+versionId).show();
        }
        
        function getAudioVersion(characterId,versionId){
            console.log("getAudioVersion")
            const token = $('.csrfToken').data('csrf-token');
            const params = { 
                characterId,
                versionId,
                sceneId:{{scene.id}},
                _csrf: token
            };
            $.get('/audio/getAudioVersions', params, function(data) {
                //data: audioVersion[].id
                //                    .doubleur:{name,id}
                //                    .name

                $(".lineCharacter_"+characterId+" .selectAudioVersion").show();
                console.log(data.versions, characterId)
                if(data.versions)
                {
                    var selectAudioVersion=$(".lineCharacter_"+characterId+" .selectAudioVersion select");
                    var selectAudioVersion=$(".selectAudioVersion_"+characterId+" select");
                    
                    console.log(selectAudioVersion)
                    $(".selectAudioVersion_"+characterId+" select .versionOption").remove();
                    //selectAudioVersion.find("option.audioVersionOption").remove();
                    for(let version of data.versions)
                    {
                        selectAudioVersion.prepend(`<option class="versionOption" value=${version.id}>${version.name}-${version.audios.length}/${data.lines.length}</option>`);
                    }
                }
            });
        }

        function createNewLineVersion(characterId){
            const token = $('.csrfToken').data('csrf-token');
            const params = { 
                characterId:characterId,
                sceneId:{{scene.id}},
                _csrf: token
            };
            $(".selectAudioVersion_"+characterId+" select .versionOption").remove();
            $.post("/lines/createNewVersion",params,function(data){
                console.log(data);
                versionId=data.version.id;
                $(`.selectLineVersion_${characterId} select`).prepend(`<option value="${versionId}">${data.version.name}</option>`);
                $(`.selectLineVersion_${characterId} select`).val(versionId);
                for(let line of data.lines)
                {
                    $(".linePosition_"+line.position).hide();
                    $(".linePosition_"+line.position+".line_newLine").show();
                    $(".linePosition_"+line.position+".line_newLine textarea").attr("id","lineText_"+line.id)
                    $(".linePosition_"+line.position+".line_newLine textarea")
                        .on("input",function(){
                            updateText(line.id);
                        })
                }
            })
        }
    ////////////////////
    // AUDIO VERSION SELECTION
    ////////////////////    
        $(".selectAudioVersion select").on('change',async function(){
            //alert($(this).val()+$(this).data('character-id'))
            const parentContainer = $(this).closest(".line");
            const deleteButton = parentContainer.find(".btnDelete").get(0);
            var characterId=$(this).data('character-id');
            var audioVersionId=parseInt($(this).val());
            $(".selectAudioVersion_"+characterId+" select").val(audioVersionId);
            const position = $(this).closest(".line").attr("data-position")
            globalAudios[position] = 0; // declaring default one as robot
            switch(audioVersionId){
                case "":
                break;
                case 0:
                    console.log("on écoute le robot");
                    $(".lineCharacter_"+characterId+" .btnAction").hide();
                    $(".lineCharacter_"+characterId+" .btnRobotizeStart").show();
                break;
                case -1:
                    let version=await createAudioVersion(characterId);
                    updateAudioVersionSelectDisplay(characterId,version)
                break;
                default:
                    characterToAudioVersion[characterId] = audioVersionId;
                    console.log(characterToAudioVersion, "s")
                    getAudioPaths(audioVersionId,characterId); 
                    if(globalAudios[position]) {
                        displayAudioReader(characterId);
                    } else { // no audio record found
                        displayRecorder(characterId);
                    }
            }
        })
        function updateAudioVersionSelectDisplay(characterId,version)
        {
            $(`.selectAudioVersion_${characterId} select`).prepend(`<option class="versionOption" value="${version.id}">${version.name}</option>`);
            $(`.selectAudioVersion_${characterId} select`).val(version.id);

            $(".lineCharacter_"+characterId+" .btnAction").hide();
            $(".lineCharacter_"+characterId+" .btnRecordControl").show();
        }

        function getLineIds(characterId){
            console.log($(".lineCharacter_"+characterId).length);
            return $(".lineCharacter_"+characterId).map((el)=>{return $(el).data('lineId')});
        }

        function getPosition(lineId)
        {
            return $('#line_'+lineId)[0].dataset['position'];
        }
        function updateAudioActionBtnDisplay(status,position){
            switch(status){
                case "robotStart":
                    $(".linePosition_"+position+" .btnAction").hide();
                    $(".linePosition_"+position+" .btnRobotizeStart").show();
                break;
                case "robotPause":
                    $(".linePosition_"+position+" .btnAction").hide();
                    $(".linePosition_"+position+" .btnRobotizePause").show();
                break;
                case "waitForRecording":
                    $(".linePosition_"+position+" .btnAction").hide();
                    $(".linePosition_"+position+" .btnStartRecord").show();
                break;  
                case "Recording":
                    $(".linePosition_"+position+" .btnAction").hide();
                    $(".linePosition_"+position+" .btnStopRecord").show();
                break;   
                case "HaveMyAudio":
                    $(".linePosition_"+position+" .btnAction").hide();
                    $(".linePosition_"+position+" .btnPlay").show();
                    $(".linePosition_"+position+" .btnDelete").show();
                break;
                case "isPlaying":
                    $(".linePosition_"+position+" .btnAction").hide();
                    $(".linePosition_"+position+" .btnPause").show();
                break;
                case "HaveOtherAudio":
                    $(".linePosition_"+position+" .btnAction").hide();
                    $(".linePosition_"+position+" .btnPlay").show();
                break;
            }

        }



        function getAudioPaths(audioVersionId,characterId){
            const token = $('.csrfToken').data('csrf-token');
            const params = { 
                characterId,
                audioVersionId,
                sceneId:{{scene.id}},
                _csrf: token
            };
            $.get('/audio/getAudiosFromAudioVersion', params, function(data) {
                console.log("getAudiosFromAudioVersionAnswer",data)
                for (let audio of data) {
                    
                    globalAudios[audio.line.position] = audio.public_path;
                    const parentElement = document.getElementById(`line_${audio.line.id}`);
                    const deleteButton = $(parentElement).find(".btnDelete").get(0);
                    $(deleteButton).attr("data-audio-id", audio.id)
                }
                
                console.log("getAudioVersionAnswer",data)
                displayAudioReader(characterId);
            });
        }
        function displayRecorder(characterId){
            $(".lineCharacter_"+characterId+" .btnAction").hide();
            $(".lineCharacter_"+characterId+" .btnRecordControl").show();
        }

        function displayAudioReader(characterId){
            $(".lineCharacter_"+characterId+" .btnAction").hide();
            $(".lineCharacter_"+characterId+" .btnAudio").show();
        }


        ////////////////////
        // AUDIO RECORD
        ////////////////////

        const createAudioVersion = async (characterID) => {
            let form = new FormData();
            form.append("characterId", characterID)
            const result = await (await fetch(`${window.location.origin}/audios/createNewVersion`, {
                method: "POST",
                headers: {
                    'X-CSRF-Token': $('.csrfToken').data('csrf-token'),
                    /* 'Accept': `${blob.type}`, // FIXME: Not working while file transfer?
                    'Content-Type': `${blob.type}`,*/ 
                    'Content-Transfer-Encoding': 'base64'
                },
                mode: "cors",
                body: form
            })).json()
            return result;
        }

        const uploadAudio = async (event, objectURL) => {
            const groupId = window.location.pathname.match(/group\/(\d+)/)[1]; // this is for authorization feature
            const parentContainer = $(event.target).closest(".line");
            console.log(parentContainer)
            const position = parentContainer.attr("data-position");
            console.log(parentContainer.attr("data-position"))
            const audioVersionSelect = $(event.target.parentNode).find(".selectAudioVersion select").get(0);
            console.log(audioVersionSelect)
            const characterID = $(event.target).closest(".line").attr("data-character-id");
            const lineID = $(parentContainer).attr("data-line-id");
            /* console.log("uploading audio!!", objectURL)
            console.log(`Here's the line_id to attach: ${lineID}`); */
            event.target.style.display = "none";
            const deleteButton = event.target.parentNode.querySelector(".btnDelete");
            deleteButton.style.display = "inline";
            /* const recordControlButton = event.target.parentNode.querySelector(".btnRecordControl");
            const recordIcon = recordControlButton.querySelector("i");
            recordIcon.classList.remove("fa-play");
            recordIcon.classList.add("fa-microphone");
            event.target.parentNode.querySelector(".btnRecordControl span:nth-child(2)").textContent = "Enregistrer !"; */
            player.currentTime = 0;
            player.src = "";
            let audioVersionID = audioVersionSelect.options[audioVersionSelect.selectedIndex].value;
            if (audioVersionID < 0 ) { // its value is -1
                console.log("mapping audio version to character")
                const result = await createAudioVersion(characterID);
                console.log(result)
                audioVersionID = result.id;
                
                const audioVersionOption = document.createElement("option");
                audioVersionOption.value=audioVersionID;
                audioVersionOption.text = result.name;
                audioVersionSelect.add(audioVersionOption);
                $(audioVersionSelect).val(audioVersionID).select().trigger("change");
            }
            characterToAudioVersion[characterID] = audioVersionID
            console.log("deneme", objectURL)
            const blob = await fetch(objectURL).then(r => r.blob());
            console.log(blob, audioVersionID, lineID);
            form = new FormData();
            form.append("audio", blob);
            form.append("lineId", lineID);
            form.append("versionId", audioVersionID);
            form.append("groupId", groupId);
            fetch(`${window.location.origin}/audios`, {
                method: "POST",
                headers: {
                    'X-CSRF-Token': $('.csrfToken').data('csrf-token'),
                    /* 'Accept': `${blob.type}`, // FIXME: Not working while file transfer?
                    'Content-Type': `${blob.type}`,*/ 
                    'Content-Transfer-Encoding': 'base64'
                },
                mode: "cors",
                body: form
            }).then(response => {
                if (!response.ok) throw response;
                console.log(response)
                return response.json();
            }).then((data) => {
                globalAudios[position] = data.public_path;
                $(deleteButton).attr("data-audio-id", data.id);
                // window.location.reload();
            }).catch((err) => {
                console.error(err);
            })



            };

            const deleteRecording = (event, objectURL=null) => {
                const groupId = window.location.pathname.match(/group\/(\d+)/)[1]; // this is for authorization feature
                const parentContainer = $(event.target).closest(".line");
                console.log(parentContainer)
                const deleteButton = $(parentContainer).find(".btnDelete").get(0);
                const position = parentContainer.attr("data-position");
                const audioId = $(event.target).attr("data-audio-id");
                console.log("canceling recording :", objectURL)
                $(parentContainer).find(".btnAudio").hide();
                console.log($(parentContainer).find(".btnAudio").hide())
                displayRecorder($(parentContainer).attr("data-character-id"));
                const recordControlButton = event.target.parentNode.querySelector(".btnRecordControl");
                
                const form = new FormData();
                form.append("groupId", groupId);
                const recordIcon = recordControlButton.querySelector("i");
                recordIcon.classList.remove("fa-play");
                recordIcon.classList.add("fa-microphone");
                event.target.parentNode.querySelector(".btnRecordControl span:nth-child(2)").textContent = "Enregistrer !";
                player.currentTime = 0;
                player.src = "";

                URL.revokeObjectURL(objectURL); // FIXME Invalid URI. Load of media resource  failed.
                fetch(`${window.location.origin}/audios/${audioId}`, {
                    method: "DELETE",
                    headers: {
                        'X-CSRF-Token': $('.csrfToken').data('csrf-token'),
                        /* 'Accept': `${blob.type}`, // FIXME: Not working while file transfer?
                        'Content-Type': `${blob.type}`,*/ 
                        'Content-Transfer-Encoding': 'base64'
                    },
                    mode: "cors",
                    body: form
                }).then(response => {
                    if (!response.ok) throw response;
                    console.log(response)
                    return response.json();
                }).then((data) => {
                    globalAudios[position] = 0;
                    $(deleteButton).attr("data-audio-id", "");
                    // window.location.reload();
                }).catch((err) => {
                    console.error(err);
                })
            }

            const handleMediaDevice = (event, stream) => {
                const parentContainer = $(event.target).closest(".line");
                console.log(event.target);
                const options = {mimeType: "audio/webm"};
                const recordedChunks = [];
                let objectURL;
                mediaRecorder = new MediaRecorder(stream, options);
                console.log(mediaRecorder.mimeType);
                mediaRecorder.addEventListener("dataavailable", function(e) {
                    if (e.data.size > 0) recordedChunks.push(e.data);
                })
                mediaRecorder.addEventListener("stop", async (e) => {
                console.log("stopped the media recorder");
                // make the create request here!
                const blob = new Blob(recordedChunks, {type: mediaRecorder.mimeType});
                objectURL = URL.createObjectURL(blob);
                player.src = objectURL;
                // ref: https://stackoverflow.com/questions/11455515/how-to-check-whether-dynamically-attached-event-listener-exists-or-not
                // uploadButton.onclick = (_e) => uploadAudio(_e, objectURL);
                await uploadAudio(event, objectURL)
                $(parentContainer).find(".btnAction").hide();
                $(parentContainer).find(".btnAudio").show();
                // FIXME how to revoke microphone permissions?

                })
                if (mediaRecorder && mediaRecorder.state !== "recording") mediaRecorder.start();

            };

        const controlAudioRecord = (event) => { 
            const characterID = $(this).closest(".line").attr("data-character-id");
            const deleteButton = event.target.parentNode.querySelector(".btnDelete");
            const uploadButton = event.target.parentNode.querySelector(".btnUpload");
            const icon = event.target.querySelector("i");
            if (!recording) {
                event.target.querySelector("span:nth-child(2)").textContent = "Arrêter d'enregistrer !";
                recording = true;
                console.log("starting recording...");
                icon.classList.remove("fa-microphone");
                icon.classList.add("fa-stopwatch");
                event.target.classList.add("glowing");
                navigator.mediaDevices.getUserMedia({audio: true, video:false}).then((stream) => handleMediaDevice(event, stream))
            
            } else {
                event.target.querySelector("span:nth-child(2)").textContent = "Enregistrer !";
                recording = false;
                console.log("stopping recording...");
                icon.classList.remove("fa-stopwatch");
                event.target.classList.remove("glowing");
                icon.classList.add("fa-play");
                if (mediaRecorder && mediaRecorder.state === "recording") mediaRecorder.stop();
            }
            }



            ////////////////////
            // BUTTON LISTENERS
            ////////////////////
            $(".btnPlay").on('click',function(){
                const player = $("#player").get(0);
                const position = $(this).attr("data-position")
                console.log(player);
                if (globalAudios[position]) {
                    player.src = globalAudios[position];
                    player.play();
                }
            });
            $(".btnDelete").on("click", deleteRecording)


        function robotSpeak(lineId)
        {
            var text=$("#lineText_"+lineId).val();
            let message = new SpeechSynthesisUtterance(text)
            message.lang = 'fr-FR'
            speechSynthesis.speak(message);
        }


            $(".btnRecordControl").on("click", controlAudioRecord);


















































    function toggleDropdownMenu(objectType,objectId){
        window.event.stopPropagation();
        $("#dropdown-option-container").html("");
        $("#dropdown-menu-"+objectType+"-"+objectId).clone().attr('id', 'currentDropDown').appendTo("#dropdown-option-container");
        $("#dropdown-option-container").show();
        var positionTrigger = $("#dropdown-trigger-"+objectType+"-"+objectId).offset();
        console.log(positionTrigger);
        $("#dropdown-option-container").offset({top:positionTrigger.top+20, left:positionTrigger.left-200})
    }
    $(document).mouseup(function(e) 
    {
        var container = $("#dropdown-option-container, .dropdown-trigger");
        var stuffToHide=$("#dropdown-option-container");
        // if the target of the click isn't the container nor a descendant of the container
        if (!container.is(e.target) && container.has(e.target).length === 0) 
        {
            stuffToHide.hide();
        }
    });

   
    let timer = [];
   
    function updateText(lineId) {
        if(timer[lineId]!=null){
        clearTimeout(timer[lineId]);
        }
        timer[lineId] = setTimeout(()=>{sendUpdateText(lineId)}, 1000);
    }
    function sendUpdateText(lineId){
        console.log("updateText")
        const text=$(`#lineText_${lineId}`).val().trim();
        const token = $('.csrfToken').data('csrf-token');
        const params = { 
            lineId, 
            text,
            _csrf: token
        };
        $.post('/line/updateText', params, function(data) {
            console.log("updateTextData")
            if(data)
            {
                $(`#lineText_${lineId}`).parent().addClass('saved');
                setTimeout(function(){
                    $('.saved').removeClass('saved')
                }, 500);
            }
        });
    }
    
    function updateCharacter(characterId,lineId)
    {
        const token = $('.csrfToken').data('csrf-token');
        const params = { 
            lineId, 
            characterId,
            _csrf: token
        };

        $.post('/line/updateCharacter', params, function(data) {
            if(data)
            {
                $(`#select_character_line_${lineId}`).html("");
                characterClone=$(`#character_line_${characterId}_${lineId}`).clone();
                characterClone.appendTo(`#select_character_line_${lineId}`);
                characterClone.find('.caret').show();
            }
        });
    }

    function auto_grow(element) {
        element.style.height = "30px";
        element.style.minHeight = "60px";
        element.style.height = (element.scrollHeight)+"px";
    }
    [...document.getElementsByClassName('lineText')].forEach((element)=>{
        auto_grow(element)
    })    
    </script>
    
    
@endsection